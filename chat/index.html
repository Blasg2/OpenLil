<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <link rel="manifest" href="/manifest.webmanifest">

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Lil's Life Chat</title>

  <style>
/* Hide header when in iframe */
body.in-iframe #chatHeader {
    display: none;
}


    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #0a0a0a;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    body.modal-open { overflow: hidden; }

    body.no-select, body.no-select * {
      -webkit-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
    }

    /* Boot overlay to avoid nickname screen flashing */
    #bootOverlay {
      position: fixed;
      inset: 0;
      background: #0a0a0a;
      z-index: 20000;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #ddd;
      font-size: 14px;
      letter-spacing: 0.2px;
    }
    #bootOverlay.hidden { display: none; }

    /* HEADER */
    #chatHeader {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      z-index: 100;
    }
    #chatTitle { flex: 1; min-width: 0; }
    #chatTitle h1 { font-size: 18px; font-weight: 600; }
    #chatTitle p { font-size: 12px; opacity: 0.9; margin-top: 2px; }

    /* red notif hint */
    #notifHint {
      display: none;
      align-items: center;
      gap: 8px;
      background: rgba(255, 35, 35, 0.95);
      color: #fff;
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: 0 8px 22px rgba(0,0,0,0.35);
    }
    #notifHint.show { display: inline-flex; }
    #notifHint .arrow { font-weight: 900; opacity: 0.95; }

    /* bell */
    #pushBtn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: none;
      background: rgba(255,255,255,0.18);
      color: white;
      font-size: 18px;
      cursor: pointer;
      flex-shrink: 0;
    }
    #pushBtn:active { transform: scale(0.98); opacity: 0.95; }

    /* NICKNAME SETUP */
    #nicknameScreen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    #nicknameScreen.hidden { display: none; }

    .nickname-card {
      background: white;
      padding: 40px 30px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      width: 100%;
      max-width: 400px;
    }
    .nickname-card h2 { color: #333; margin-bottom: 10px; font-size: 24px; }
    .nickname-card p { color: #666; margin-bottom: 25px; font-size: 14px; }

    #nicknameInput {
      width: 100%;
      padding: 15px;
      border: 2px solid #667eea;
      border-radius: 12px;
      font-size: 16px;
      margin-bottom: 20px;
      outline: none;
    }
    #nicknameInput:focus { border-color: #764ba2; }

    #enterChatBtn {
      width: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 15px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
    }

    /* CHAT SCREEN */
    #chatScreen { display: none; flex-direction: column; height: 100vh; }
    #chatScreen.active { display: flex; }

    /* MESSAGES AREA (oldest top, newest bottom) */
    #messagesContainer {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
    }

    /* "loading older..." hint */
    #olderLoading {
      display: none;
      text-align: center;
      color: #aaa;
      font-size: 12px;
      padding: 8px 0 10px 0;
      opacity: 0.9;
    }
    #olderLoading.active { display: block; }

    .message { margin-bottom: 12px; animation: slideIn 0.2s ease; }
    @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .message-bubble {
      background: #1f1f1f;
      padding: 10px 12px;
      border-radius: 12px;
      max-width: 80%;
      word-wrap: break-word;
      position: relative;

      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;

      touch-action: pan-y;
    }
    .message-bubble * {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .message-bubble.highlight { animation: highlightWhole 4s ease; }
    @keyframes highlightWhole {
      0%   { background: #1f1f1f; box-shadow: 0 0 0 rgba(102,126,234,0); }
      10%  { background: #2a2a44; box-shadow: 0 0 0 8px rgba(102,126,234,0.22); }
      70%  { background: #2a2a44; box-shadow: 0 0 0 8px rgba(102,126,234,0.22); }
      100% { background: #1f1f1f; box-shadow: 0 0 0 rgba(102,126,234,0); }
    }

    .message-nickname { font-weight: bold; font-size: 13px; margin-bottom: 4px; }
    .message-text { color: #e8e8e8; font-size: 15px; line-height: 1.4; }

    /* Lil username - simple blue */
    .lil-username {
      color: rgb(44, 120, 173) !important;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Scrolling pride flag */
    .pride-flag {
      width: 24px;
      height: 18px;
      background: repeating-linear-gradient(180deg, 
        #e40303 0px, #e40303 3px,
        #ff8c00 3px, #ff8c00 6px,
        #ffed00 6px, #ffed00 9px,
        #008026 9px, #008026 12px,
        #24408e 12px, #24408e 15px,
        #732982 15px, #732982 18px);
      animation: pride-scroll 2s linear infinite;
      border-radius: 2px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    @keyframes pride-scroll {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 0 18px;
      }
    }

    /* Lorena username - pretty girl pink */
    .lorena-username {
      color: #ff69b4 !important;
    }

    /* Gui username - Evangelion purple */
    .gui-username {
      color: #9333ea !important;
    }

    /* Lorena kisses container */
    .lorena-container {
      position: relative;
      display: inline-block;
    }

    .kiss {
      position: absolute;
      font-size: 16px;
      animation: float-kiss 3s ease-in-out infinite;
      opacity: 0;
      pointer-events: none;
    }

    .kiss:nth-child(1) {
      animation-delay: 0s;
      left: -20px;
      top: -5px;
    }

    .kiss:nth-child(2) {
      animation-delay: 1s;
      right: -20px;
      top: -5px;
    }

    .kiss:nth-child(3) {
      animation-delay: 2s;
      left: -15px;
      top: 10px;
    }

    @keyframes float-kiss {
      0% {
        opacity: 0;
        transform: translateY(0) rotate(0deg) scale(0.5);
      }
      20% {
        opacity: 1;
      }
      80% {
        opacity: 1;
      }
      100% {
        opacity: 0;
        transform: translateY(-30px) rotate(15deg) scale(1);
      }
    }

    .message-image {
      max-width: 250px;
      width: 100%;
      border-radius: 8px;
      margin-top: 5px;
      cursor: pointer;
      display: block;

      -webkit-user-drag: none;
      user-drag: none;
    }

    .message-time {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
      text-align: right;
    }

    /* Delete button */
    .message-delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: none;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      font-size: 12px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
      transition: opacity 0.2s;
    }

    .message-delete-btn:hover {
      opacity: 1;
    }

    .message-delete-btn:active {
      transform: scale(0.9);
    }

    .message-bubble:hover .message-delete-btn {
      display: flex;
    }

    /* Reply preview */
    .reply-preview {
      background: rgba(255,255,255,0.06);
      border-left: 3px solid #667eea;
      padding: 8px 10px;
      border-radius: 10px;
      margin-bottom: 8px;
      cursor: pointer;
    }
    .reply-preview:active { opacity: 0.9; }

    .reply-preview .reply-name {
      font-size: 12px;
      font-weight: 700;
      opacity: 0.95;
      margin-bottom: 4px;
    }

    .reply-preview-row {
      display: flex;
      gap: 10px;
      align-items: center;
      min-height: 22px;
    }

    .reply-thumb {
      width: 34px;
      height: 34px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);

      -webkit-user-drag: none;
      user-drag: none;
    }

    .reply-preview .reply-snippet {
      font-size: 13px;
      opacity: 0.9;
      color: #ddd;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      flex: 1;
      min-width: 0;
    }

    /* INPUT AREA */
    #inputArea {
      background: #1a1a1a;
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: flex-end;
      border-top: 1px solid #2a2a2a;
      position: relative;
      z-index: 120;
    }

    #imageBtn, #sendBtn {
      background: #667eea;
      border: none;
      color: white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    #audioBtn {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      border: none;
      background: #667eea;
      color: white;
      font-size: 20px;
      cursor: pointer;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #audioBtn:active { transform: scale(0.95); }

    #audioBtn.recording {
      background: #ef4444;
      animation: pulse-recording 1.5s ease-in-out infinite;
    }

    @keyframes pulse-recording {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Recording indicator */
    #recordingIndicator {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(239, 68, 68, 0.15);
      border-radius: 20px;
      color: #ef4444;
      font-size: 13px;
      font-weight: 600;
      position: absolute;
      bottom: 70px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 130;
    }

    #recordingIndicator.active {
      display: flex;
    }

    .recording-dot {
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse-dot 1s ease-in-out infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.8); }
    }

    /* Audio player in messages */
    .message-audio {
      margin-top: 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .audio-play-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: #667eea;
      color: white;
      font-size: 16px;
      cursor: pointer;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .audio-play-btn:active {
      transform: scale(0.95);
    }

    .audio-waveform {
      flex: 1;
      height: 3px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      position: relative;
      overflow: hidden;
    }

    .audio-progress {
      height: 100%;
      background: #667eea;
      width: 0%;
      transition: width 0.1s linear;
    }

    .audio-time {
      font-size: 11px;
      color: #aaa;
      min-width: 35px;
      text-align: right;
    }

    .audio-speed-btn {
      font-size: 11px;
      color: #667eea;
      background: rgba(102, 126, 234, 0.15);
      border: none;
      padding: 4px 8px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      flex-shrink: 0;
    }

    .audio-speed-btn:active {
      transform: scale(0.95);
    }

    /* Oi play button */
    .oi-play-btn {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: none;
      background: #667eea;
      color: white;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 8px;
      flex-shrink: 0;
    }

    .oi-play-btn:active {
      transform: scale(0.9);
    }

    #messageInput {
      flex: 1;
      background: #2a2a2a;
      border: none;
      color: white;
      padding: 12px 15px;
      border-radius: 22px;
      font-size: 16px;
      outline: none;
      max-height: 100px;
      resize: none;
    }

    /* Upload status above input */
    #uploadStatus {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 86px;
      background: #667eea;
      color: white;
      padding: 10px 16px;
      border-radius: 18px;
      font-size: 14px;
      z-index: 1000;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }

    /* Reply bar above input */
    #replyBar {
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #141414;
      border-top: 1px solid #2a2a2a;
      z-index: 120;
    }
    #replyBar.active { display: flex; }

    #replyBarLeft {
      flex: 1;
      border-left: 3px solid #667eea;
      padding-left: 10px;
      overflow: hidden;
      min-width: 0;
    }
    #replyBarTitle {
      color: white;
      font-size: 12px;
      font-weight: 700;
      opacity: 0.95;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #replyBarText {
      color: #bbb;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #replyCancelBtn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: none;
      background: #2a2a2a;
      color: white;
      font-size: 18px;
      cursor: pointer;
      flex-shrink: 0;
    }

    /* Scroll-to-bottom button */
    #scrollToBottomBtn {
      position: fixed;
      right: 16px;
      bottom: 96px; /* above input */
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: none;
      background: rgba(102,126,234,0.92);
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: none;
      z-index: 1500;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
    #scrollToBottomBtn.show { display: block; }
    #scrollToBottomBtn:active { transform: scale(0.98); opacity: 0.95; }

    /* LIGHTBOX */
    #lightbox {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    #lightbox.active { display: flex; }
    #lightbox img { max-width: 100%; max-height: 100%; border-radius: 10px; }
    #closeLightbox {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #ff4444;
      color: white;
      border: none;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
    }

    /* IMAGE SOURCE MODAL */
    #imageSourceModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      padding: 20px;
    }
    #imageSourceModal.active { display: flex; }

    .image-source-card {
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      width: 100%;
      max-width: 360px;
      border-radius: 18px;
      padding: 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    .image-source-card h3 { color: white; font-size: 16px; margin-bottom: 12px; opacity: 0.95; }

    .image-source-card button {
      width: 100%;
      border: none;
      padding: 14px 14px;
      border-radius: 14px;
      font-size: 16px;
      cursor: pointer;
      margin-top: 10px;
    }
    .image-source-card .primary { background: #667eea; color: white; }
    .image-source-card .secondary { background: #2a2a2a; color: white; }
    .image-source-card .cancel { background: transparent; color: #aaa; }

    /* MESSAGE ACTION POPUP */
    #msgActionModal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      z-index: 10001;
      align-items: flex-end;
      justify-content: center;
      padding: 16px;
    }
    #msgActionModal.active { display: flex; }

    .msg-action-sheet {
      width: 100%;
      max-width: 480px;
      background: #1a1a1a;
      border: 1px solid #2a2a2a;
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }

    .msg-action-preview {
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      margin-bottom: 10px;
    }
    .msg-action-preview .p1 { color: white; font-size: 13px; font-weight: 700; margin-bottom: 6px; }

    .msg-action-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .msg-action-thumb {
      width: 42px;
      height: 42px;
      border-radius: 10px;
      object-fit: cover;
      flex-shrink: 0;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      display: none;
      -webkit-user-drag: none;
      user-drag: none;
    }
    .msg-action-text {
      color: #cfcfcf;
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }

    .msg-action-sheet button {
      width: 100%;
      padding: 14px;
      border-radius: 14px;
      border: none;
      font-size: 16px;
      cursor: pointer;
      margin-top: 8px;
    }
    .msg-action-sheet .reply { background: #667eea; color: white; }
    .msg-action-sheet .cancel { background: transparent; color: #aaa; }
  </style>
</head>

<body>
  <div id="bootOverlay">Carregando‚Ä¶</div>

  <!-- LIGHTBOX -->
  <div id="lightbox" onclick="closeLightbox()">
    <button id="closeLightbox">√ó</button>
    <img id="lightboxImage" src="" alt="Full size" onclick="event.stopPropagation()">
  </div>

  <!-- IMAGE SOURCE MODAL -->
  <div id="imageSourceModal" onclick="closeImageSource()">
    <div class="image-source-card" onclick="event.stopPropagation()">
      <h3>Enviar imagem</h3>
      <button class="primary" onclick="openCamera()">üì∑ C√¢mera</button>
      <button class="secondary" onclick="openGallery()">üñºÔ∏è Galeria</button>
      <button class="cancel" onclick="closeImageSource()">Cancelar</button>
    </div>
  </div>

  <!-- Hidden inputs -->
  <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none"
         onchange="handleImageSelect(event)">
  <input type="file" id="galleryInput" accept="image/*" style="display:none"
         onchange="handleImageSelect(event)">

  <!-- Message action popup -->
  <div id="msgActionModal" onclick="closeMsgActions()">
    <div class="msg-action-sheet" onclick="event.stopPropagation()">
      <div class="msg-action-preview">
        <div class="p1" id="msgActionName">Usu√°rio</div>
        <div class="msg-action-row">
          <img id="msgActionThumb" class="msg-action-thumb" alt="thumb">
          <div class="msg-action-text" id="msgActionText">Mensagem‚Ä¶</div>
        </div>
      </div>
      <button class="reply" onclick="startReplyFromAction()">Responder</button>
      <button class="cancel" onclick="closeMsgActions()">Cancelar</button>
    </div>
  </div>

  <!-- NICKNAME SCREEN -->
  <div id="nicknameScreen">
    <div class="nickname-card">
      <h2>Bem-vindo!</h2>
      <p>Escolha um apelido para entrar no chat</p>
      <input type="text" id="nicknameInput" placeholder="Seu apelido..." maxlength="20">
      <button id="enterChatBtn" onclick="enterChat()">Entrar no Chat</button>
    </div>
  </div>

  <!-- CHAT SCREEN -->
  <div id="chatScreen">
    <div id="chatHeader">
      <div id="chatTitle">
        <h1>Lil's Chat</h1>
        <p>Esperando doming√£o edition</p>
      </div>

      <div id="notifHint"><span>Clique para ativar notifica√ß√µes</span> <span class="arrow">‚Üí</span></div>

      <button id="pushBtn" title="Ativar notifica√ß√µes" onclick="enableNotifications()">üîî</button>
    </div>

    <div id="uploadStatus"></div>

    <div id="olderLoading">Carregando mensagens antigas‚Ä¶</div>
    <div id="messagesContainer"></div>

    <div id="replyBar">
      <div id="replyBarLeft">
        <div id="replyBarTitle">Respondendo</div>
        <div id="replyBarText">‚Ä¶</div>
      </div>
      <button id="replyCancelBtn" onclick="cancelReply()">√ó</button>
    </div>

    <div id="inputArea">
      <button id="imageBtn" onclick="openImageSource()">üì∑</button>
      <button id="audioBtn" onclick="toggleAudioRecording()">üé§</button>
      <textarea id="messageInput" placeholder="Mensagem..." rows="1"></textarea>
      <button id="sendBtn" onclick="sendMessage()">‚û§</button>
    </div>
    
    <!-- Recording indicator -->
    <div id="recordingIndicator">
      <div class="recording-dot"></div>
      <span id="recordingTime">0:00</span>
    </div>
  </div>

  <!-- Scroll-to-bottom button -->
  <button id="scrollToBottomBtn" title="Ir para o final" onclick="jumpToBottom()">‚Üì</button>

  <!-- Firebase compat -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAzpUnWhMkePhLgwf22aA8YUzrUJUc_RlE",
      authDomain: "lilslife.firebaseapp.com",
      databaseURL: "https://lilslife-default-rtdb.firebaseio.com",
      projectId: "lilslife",
      storageBucket: "lilslife.firebasestorage.app",
      messagingSenderId: "731094352991",
      appId: "1:731094352991:web:6ac2b5b02253f4915947ea"
    };

    firebase.initializeApp(firebaseConfig);

    const database = firebase.database();
    const auth = firebase.auth();
    const storage = firebase.storage();

    // FCM
    const messaging = firebase.messaging();
    const VAPID_PUBLIC_KEY = "BEosaFitBubtud4pjzqWwzjldLIUyoI0W2-51bM17I0Cww0A3gG3HtQTWMaXUCoxHS4tO0OZp-q_1k_aVaUukgE";

    const messagesRef = database.ref('messages');
    const IMGBB_API_KEY = '18ab4a20c315acaf53a635943d332eba';

    let userNickname = null;
    let userColor = null;

    let userId = null;
    let authReady = false;

    let replyTarget = null;
    let actionTarget = null;

    // Audio recording
    let mediaRecorder = null;
    let audioChunks = [];
    let recordingStartTime = null;
    let recordingTimer = null;
    let isRecording = false;

    // Paging + loaded tracking
    const PAGE_SIZE = 60;
    let oldestTs = null;
    let newestTs = 0;
    let isLoadingOlder = false;
    const loadedMessageIds = new Set();
    let newMsgListenerQuery = null;


        // Tell service worker that chat is open (resets notification count)
    if ("serviceWorker" in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({ type: "CHAT_OPENED" });
    }

    // Scroll button logic
    const SCROLL_BOTTOM_THRESHOLD_PX = 220; // when farther than this from bottom -> show btn

    const NOTIF_HINT_KEY = "notifHintDismissed";

    const colors = [
      '#FF6B6B', '#E74C3C', '#C0392B', '#E74292', '#FF1744',
      '#D32F2F', '#C2185B', '#AD1457', '#880E4F', '#F06292',
      '#EC407A', '#E91E63', '#FF4081', '#F50057', '#C51162',
      '#FF9800', '#F57C00', '#E65100', '#FF6F00', '#FF5722',
      '#E64A19', '#D84315', '#BF360C', '#FFA726', '#FB8C00',
      '#FFD54F', '#FFC107', '#FFB300', '#FFA000', '#FF8F00',
      '#F9A825', '#F57F17', '#FFD600', '#FFEA00', '#F4B400',
      '#4CAF50', '#388E3C', '#2E7D32', '#1B5E20', '#00C853',
      '#00E676', '#69F0AE', '#00BFA5', '#1DE9B6', '#00897B',
      '#00695C', '#004D40', '#66BB6A', '#43A047', '#2E7D32',
      '#81C784', '#66BB6A', '#4CAF50', '#8BC34A', '#9CCC65',
      '#7CB342', '#689F38', '#558B2F', '#33691E', '#C5E1A5',
      '#00BCD4', '#00ACC1', '#0097A7', '#00838F', '#006064',
      '#26C6DA', '#00B8D4', '#00E5FF', '#84FFFF', '#18FFFF',
      '#2196F3', '#1E88E5', '#1976D2', '#1565C0', '#0D47A1',
      '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C',
      '#673AB7', '#5E35B1', '#512DA8', '#4527A0', '#311B92'
    ];

    document.addEventListener('contextmenu', (e) => {
      if (e.target.closest('.message-bubble') || e.target.closest('.reply-preview') || e.target.closest('.msg-action-sheet')) {
        e.preventDefault();
        e.stopPropagation();
      }
    }, { capture: true });

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text ?? '';
      return div.innerHTML;
    }

    function snippetFromMsg(msg) {
      if (!msg) return '';
      if (msg.imageUrl) return '';
      if (msg.message) return msg.message.replace(/\s+/g, ' ').trim();
      return '';
    }

    function buildReplyTargetFromBubble(bubbleEl) {
      return {
        id: bubbleEl.getAttribute('data-id') || '',
        nickname: bubbleEl.getAttribute('data-nickname') || '',
        color: bubbleEl.getAttribute('data-color') || '#667eea',
        text: bubbleEl.getAttribute('data-snippet') || '',
        imageUrl: bubbleEl.getAttribute('data-imageurl') || null,
        audioUrl: bubbleEl.getAttribute('data-audiourl') || null
      };
    }

    function setOlderLoading(isOn) {
      document.getElementById('olderLoading').classList.toggle('active', !!isOn);
    }

    function showScrollBtn(show) {
      document.getElementById('scrollToBottomBtn').classList.toggle('show', !!show);
    }

    function distanceFromBottom(container) {
      return (container.scrollHeight - (container.scrollTop + container.clientHeight));
    }

    function jumpToBottom() {
      const c = document.getElementById('messagesContainer');
      c.scrollTop = c.scrollHeight;
      showScrollBtn(false);
    }

    function hideNotifHintForever() {
      localStorage.setItem(NOTIF_HINT_KEY, "1");
      document.getElementById('notifHint').classList.remove('show');
    }

    function refreshNotifHintVisibility() {
      const dismissed = localStorage.getItem(NOTIF_HINT_KEY) === "1";
      // If already granted, don't show the hint either.
      const alreadyGranted = ("Notification" in window) && Notification.permission === "granted";
      const shouldShow = !dismissed && !alreadyGranted;
      document.getElementById('notifHint').classList.toggle('show', shouldShow);
    }

    // ========= AUTH BOOTSTRAP =========
    async function ensureAnonAuth() {
      if (auth.currentUser) return auth.currentUser;
      const cred = await auth.signInAnonymously();
      return cred.user;
    }

async function loadNicknameFromDbOrLocal(uid) {
  try {
    const snap = await database.ref(`users/${uid}/profile/nickname`).once('value');
    const nick = (snap.val() || '').trim();
    if (nick) return nick;
  } catch {}
  // IMPORTANT: no local fallback.
  // If the DB nickname/profile is deleted, user must re-pick.
  return null;
}


    async function loadColorFromLocal() {
      const c = (localStorage.getItem('chatColor') || '').trim();
      return c || null;
    }

    async function boot() {
      // main SW (simple)
      if ("serviceWorker" in navigator) {
        try { await navigator.serviceWorker.register("/sw.js"); } catch {}
      }

      const user = await ensureAnonAuth();
      userId = user.uid;
      authReady = true;

      userNickname = await loadNicknameFromDbOrLocal(userId);
      userColor = await loadColorFromLocal();

      if (userNickname && userColor) {
        await database.ref('activeUsers/' + userId).set({
          nickname: userNickname,
          color: userColor,
          timestamp: Date.now()
        });
        database.ref('activeUsers/' + userId).onDisconnect().remove();

        showChat();
      } else {
        document.getElementById('nicknameScreen').classList.remove('hidden');
      }

      document.getElementById('bootOverlay').classList.add('hidden');

      // now that UI exists, show/hide notif hint
      refreshNotifHintVisibility();
    }

    boot().catch((e) => {
      console.error(e);
      document.getElementById('bootOverlay').textContent = "Erro ao carregar.";
    });

async function isNicknameTakenInUsers(nickname) {
  const want = nickname.trim().toLowerCase();

  const snap = await database.ref('users').once('value');
  const users = snap.val() || {};

  for (const uid of Object.keys(users)) {
    const n = String(users[uid]?.profile?.nickname || '').trim().toLowerCase();
    if (n && n === want) return true;
  }
  return false;
}



    async function enterChat() {
  if (!authReady || !userId) {
    alert("Auth ainda n√£o carregou. Tenta de novo em 1s.");
    return;
  }

  const input = document.getElementById('nicknameInput');
  const nickname = input.value.trim();
  if (nickname.length < 2) {
    alert('Apelido deve ter pelo menos 2 caracteres!');
    return;
  }

  // Check if nickname already exists anywhere under users/*/profile/nickname
  const want = nickname.toLowerCase();
  const usersSnap = await database.ref('users').once('value');
  const users = usersSnap.val() || {};
  for (const uid of Object.keys(users)) {
    const existing = String(users[uid]?.profile?.nickname || '').trim().toLowerCase();
    if (existing && existing === want) {
      // allow the same user to re-use their own nickname
      if (uid === userId) break;

      alert("Esse apelido j√° existe. Escolha outro.");
      return;
    }
  }

  userNickname = nickname;

  const snapshot = await database.ref('activeUsers').once('value');
  const activeUsers = snapshot.val() || {};
  const usedColors = Object.values(activeUsers).map(u => u.color);

  let availableColors = colors.filter(c => !usedColors.includes(c));
  if (availableColors.length === 0) availableColors = colors;
  userColor = availableColors[Math.floor(Math.random() * availableColors.length)];

  localStorage.setItem('chatNickname', userNickname);
  localStorage.setItem('chatColor', userColor);

  await database.ref(`users/${userId}/profile`).set({
    nickname: userNickname,
    color: userColor,
    updatedAt: Date.now()
  });

  await database.ref('activeUsers/' + userId).set({
    nickname: userNickname,
    color: userColor,
    timestamp: Date.now()
  });
  database.ref('activeUsers/' + userId).onDisconnect().remove();

  showChat();
  refreshNotifHintVisibility();
}


    function showChat() {
      document.getElementById('nicknameScreen').classList.add('hidden');
      document.getElementById('chatScreen').classList.add('active');

      initMessagesPaging();

      const textarea = document.getElementById('messageInput');
      textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
      });

      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
    }

// At the top with other variables
let hasReachedStart = false;
let oldestMessageKey = null; // Track by Firebase key instead of timestamp

async function initMessagesPaging() {
  const container = document.getElementById('messagesContainer');
  container.innerHTML = '';
  loadedMessageIds.clear();
  oldestTs = null;
  newestTs = 0;
  hasReachedStart = false;
  oldestMessageKey = null;

  container.addEventListener('scroll', () => {
    if (container.scrollTop <= 10 && !isLoadingOlder && !hasReachedStart) {
      loadOlderMessages();
    }

    const dist = distanceFromBottom(container);
    showScrollBtn(dist > SCROLL_BOTTOM_THRESHOLD_PX);
  });

  // Load initial batch
  const snap = await messagesRef.orderByKey().limitToLast(PAGE_SIZE).once('value');
  const msgs = [];
  snap.forEach((child) => {
    const msg = { id: child.key, ...child.val() };
    msgs.push(msg);
  });

  // Sort by timestamp for display
  msgs.sort((a,b) => (a.timestamp||0) - (b.timestamp||0));

  msgs.forEach(m => appendMessage(m, false));

  if (msgs.length) {
    oldestMessageKey = msgs[0].id;
    oldestTs = msgs[0].timestamp;
    newestTs = msgs[msgs.length - 1].timestamp || 0;
  }

  setTimeout(() => {
    container.scrollTop = container.scrollHeight;
    showScrollBtn(false);
  }, 100);

  startNewMessageListener();
}

function startNewMessageListener() {
  if (newMsgListenerQuery) newMsgListenerQuery.off('child_added');
  
  newMsgListenerQuery = messagesRef.orderByChild('timestamp').startAt(newestTs);

  newMsgListenerQuery.on('child_added', (child) => {
    const msg = { id: child.key, ...child.val() };
    if (!msg || !msg.id) return;
    if (loadedMessageIds.has(msg.id)) return;

    if ((msg.timestamp || 0) > newestTs) newestTs = msg.timestamp;

    const container = document.getElementById('messagesContainer');
    const wasNearBottom = distanceFromBottom(container) <= SCROLL_BOTTOM_THRESHOLD_PX;

    appendMessage(msg, false);

    if (wasNearBottom) {
      setTimeout(() => {
        container.scrollTop = container.scrollHeight;
        showScrollBtn(false);
      }, 50);
    } else {
      showScrollBtn(true);
    }
  });
}

async function loadOlderMessages() {
  if (isLoadingOlder || !oldestMessageKey || hasReachedStart) return;

  isLoadingOlder = true;
  setOlderLoading(true);

  const container = document.getElementById('messagesContainer');
  const prevScrollHeight = container.scrollHeight;
  const prevScrollTop = container.scrollTop;

  // Use orderByKey and endBefore to get messages before the oldest key
  const olderSnap = await messagesRef
    .orderByKey()
    .endBefore(oldestMessageKey)
    .limitToLast(PAGE_SIZE)
    .once('value');

  const older = [];
  olderSnap.forEach((child) => {
    older.push({ id: child.key, ...child.val() });
  });
  
  if (older.length === 0) {
    hasReachedStart = true;
    setOlderLoading(false);
    isLoadingOlder = false;
    return;
  }

  // Sort by timestamp for display order
  older.sort((a,b) => (a.timestamp||0) - (b.timestamp||0));

  // Reverse before prepending so oldest appears first
  older.reverse().forEach(m => appendMessage(m, true));
  
  // Update oldest key (first in the original sorted array, which is the oldest)
  oldestMessageKey = older[older.length - 1].id;
  oldestTs = older[older.length - 1].timestamp;

  // Maintain scroll position
  setTimeout(() => {
    const newScrollHeight = container.scrollHeight;
    const heightDiff = newScrollHeight - prevScrollHeight;
    container.scrollTop = heightDiff + prevScrollTop;
  }, 50);

  if (older.length < PAGE_SIZE) {
    hasReachedStart = true;
  }

  setOlderLoading(false);
  isLoadingOlder = false;
}

    function appendMessage(msg, prepend) {
      if (!msg || !msg.id) return;
      if (loadedMessageIds.has(msg.id)) return;
      loadedMessageIds.add(msg.id);

      const el = createMessageElement(msg);
      const container = document.getElementById('messagesContainer');

      if (prepend) container.insertBefore(el, container.firstChild);
      else container.appendChild(el);
    }

    function scrollToMessage(messageId) {
      if (!messageId) return;
      const el = document.getElementById(`msg-${messageId}`);
      if (!el) return;

      el.scrollIntoView({ behavior: 'smooth', block: 'center' });
      el.classList.remove('highlight');
      void el.offsetWidth;
      el.classList.add('highlight');
    }

    function createMessageElement(msg) {
      const div = document.createElement('div');
      div.className = 'message';

      const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      let content = '';
      if (msg.audioUrl) {
        // Audio message
        const audioId = `audio-${msg.id}`;
        content = `
          <div class="message-audio">
            <button class="audio-play-btn" onclick="toggleAudioPlay('${audioId}')">‚ñ∂</button>
            <div class="audio-waveform">
              <div class="audio-progress" id="${audioId}-progress"></div>
            </div>
            <span class="audio-time" id="${audioId}-time">0:00</span>
            <button class="audio-speed-btn" onclick="toggleAudioSpeed('${audioId}')">1x</button>
            <audio id="${audioId}" src="${escapeHtml(msg.audioUrl)}" preload="metadata"></audio>
          </div>`;
      } else if (msg.imageUrl) {
        content = `<img src="${escapeHtml(msg.imageUrl)}" class="message-image" draggable="false" onclick="openLightbox('${escapeHtml(msg.imageUrl)}')" alt="img">`;
      } else if (msg.message) {
        // Display transformed words based on transformedIndices for all users
        if (msg.transformedIndices?.length) {
          const words = msg.message.split(' ');
          content = words.map((w, i) => msg.transformedIndices.includes(i)
            ? `<span style="color:red;font-weight:bold">${escapeHtml(w)}</span>`
            : escapeHtml(w)
          ).join(' ');
        } else {
          content = escapeHtml(msg.message);
        }
      }

      let replyHtml = '';
      if (msg.replyTo && (msg.replyTo.nickname || msg.replyTo.text || msg.replyTo.imageUrl || msg.replyTo.audioUrl)) {
        const rName = escapeHtml(msg.replyTo.nickname || 'Mensagem');
        const rText = escapeHtml(msg.replyTo.text || '');
        const rColor = escapeHtml(msg.replyTo.color || '#667eea');
        const rId = escapeHtml(msg.replyTo.id || '');
        const rImg = msg.replyTo.imageUrl ? escapeHtml(msg.replyTo.imageUrl) : '';
        const rAudio = msg.replyTo.audioUrl;
        
        let snippetText = rText;
        if (rImg) snippetText = 'Imagem';
        if (rAudio) snippetText = 'üé§ √Åudio';

        replyHtml = `
          <div class="reply-preview" onclick="scrollToMessage('${rId}')">
            <div class="reply-name" style="color:${rColor}">${rName}</div>
            <div class="reply-preview-row">
              ${rImg ? `<img class="reply-thumb" draggable="false" src="${rImg}" alt="thumb">` : ``}
              <div class="reply-snippet">${snippetText}</div>
            </div>
          </div>
        `;
      }

      const isImage = !!msg.imageUrl;

      // Check for special username effects
      const nickname = msg.nickname || '';
      let nicknameHtml = '';
      
      if (nickname.toLowerCase() === 'lil' || nickname.toLowerCase() === 'lill' || nickname.toLowerCase() === 'lilll') {
        // Simple blue username for Lil, Lill, and Lilll (display all as "Lil") with scrolling pride flags on both sides
        nicknameHtml = `<div class="message-nickname lil-username"><div class="pride-flag"></div>Lil<div class="pride-flag"></div></div>`;
      } else if (nickname.toLowerCase() === 'lorena') {
        // Lorena with pretty pink color and animated kisses
        nicknameHtml = `
          <div class="message-nickname lorena-container lorena-username">
            <span class="kiss">üíã</span>
            <span class="kiss">üíã</span>
            <span class="kiss">üíã</span>
            ${escapeHtml(nickname)}
          </div>`;
      } else if (nickname.toLowerCase() === 'gui') {
        // Gui with Evangelion purple
        nicknameHtml = `<div class="message-nickname gui-username">${escapeHtml(nickname)}</div>`;
      } else {
        // Normal nickname
        nicknameHtml = `<div class="message-nickname" style="color:${escapeHtml(msg.color)}">${escapeHtml(nickname)}</div>`;
      }

      const isAudio = !!msg.audioUrl;
      let snippet = '';
      if (isAudio) snippet = 'üé§ √Åudio';
      else if (isImage) snippet = 'Imagem';
      else snippet = snippetFromMsg(msg);

      // Check if message is "oi", "ol√°", or "ola" (case insensitive)
      const messageText = (msg.message || '').trim().toLowerCase();
      const isOiMessage = messageText === 'oi' || messageText === 'ol√°' || messageText === 'ola';
      const oiButton = isOiMessage ? `<button class="oi-play-btn" onclick="playOiAudio()" title="Tocar √°udio">üîä</button>` : '';

      // Show delete button only for Gui
      const isGui = userNickname && userNickname.toLowerCase() === 'gui';
      const deleteBtn = isGui ? `<button class="message-delete-btn" onclick="deleteMessage('${escapeHtml(msg.id)}', '${escapeHtml(msg.audioUrl || '')}', '${escapeHtml(msg.imageUrl || '')}')">üóëÔ∏è</button>` : '';

      div.innerHTML = `
        <div class="message-bubble"
             oncontextmenu="return false"
             id="msg-${escapeHtml(msg.id)}"
             data-id="${escapeHtml(msg.id)}"
             data-nickname="${escapeHtml(msg.nickname)}"
             data-color="${escapeHtml(msg.color)}"
             data-snippet="${escapeHtml(snippet)}"
             data-imageurl="${escapeHtml(isImage ? msg.imageUrl : '')}"
             data-audiourl="${escapeHtml(isAudio ? msg.audioUrl : '')}">
          ${deleteBtn}
          ${replyHtml}
          ${nicknameHtml}
          <div class="message-text" style="display: flex; align-items: center;">
            <span style="flex: 1;">${content}</span>
            ${oiButton}
          </div>
          <div class="message-time">${time}</div>
        </div>
      `;

      const bubble = div.querySelector('.message-bubble');
      attachLongPressForReply(bubble);

      return div;
    }

    // ========= SEND MESSAGE (If YOU sent -> scroll bottom) =========
    function sendMessage() {
      const input = document.getElementById('messageInput');
      const message = input.value.trim();
      if (!message) return;

      if (!authReady || !userId) {
        alert("Auth ainda n√£o carregou.");
        return;
      }

      const words = message.split(' ');
      const transformedIndices = [];
      
      // If the sender is "Lil", "Lill", or "Lilll", transform words with 15% chance
      const isLil = userNickname.toLowerCase() === 'lil' || userNickname.toLowerCase() === 'lill' || userNickname.toLowerCase() === 'lilll';
      
      const transformed = words.map((w, i) => {
        if (w.toLowerCase() === 'lil') return w;
        
        if (isLil) {
          // Lil/Lill/Lilll's messages: 15% chance per word becomes "Lil"
          if (Math.random() < 0.15) {
            transformedIndices.push(i);
            return 'Lil';
          }
        } else {
          // Others: 5% chance
          if (Math.random() < 0.05) {
            transformedIndices.push(i);
            return 'Lil';
          }
        }
        return w;
      }).join(' ');

      const payload = {
        uid: userId,
        nickname: userNickname,
        message: transformed,
        color: userColor,
        timestamp: Date.now(),
        transformedIndices
      };

      if (replyTarget) {
        payload.replyTo = {
          id: replyTarget.id,
          nickname: replyTarget.nickname,
          color: replyTarget.color,
          text: replyTarget.text || '',
          imageUrl: replyTarget.imageUrl || null
        };
      }

      messagesRef.push(payload);

      input.value = '';
      input.style.height = 'auto';
      input.focus();
      cancelReply();

      // YOU sent => scroll to bottom
      jumpToBottom();
    }

    async function handleImageSelect(event) {
      const file = event.target.files[0];
      if (!file || !file.type.startsWith('image/')) return;

      if (!authReady || !userId) {
        alert("Auth ainda n√£o carregou.");
        event.target.value = '';
        return;
      }

      const status = document.getElementById('uploadStatus');
      status.style.display = 'block';
      status.textContent = 'Enviando...';

      try {
        const compressed = await compressImage(file, 500 * 1024);
        const url = await uploadToImgBB(compressed);

        const payload = {
          uid: userId,
          nickname: userNickname,
          imageUrl: url,
          color: userColor,
          timestamp: Date.now()
        };

        if (replyTarget) {
          payload.replyTo = {
            id: replyTarget.id,
            nickname: replyTarget.nickname,
            color: replyTarget.color,
            text: replyTarget.text || '',
            imageUrl: replyTarget.imageUrl || null
          };
        }

        await messagesRef.push(payload);

        status.textContent = 'Enviado!';
        setTimeout(() => status.style.display = 'none', 1600);

        cancelReply();

        // YOU sent image => scroll to bottom
        jumpToBottom();
      } catch (error) {
        status.textContent = 'Erro no envio';
        setTimeout(() => status.style.display = 'none', 2500);
      }

      event.target.value = '';
    }

    async function compressImage(file, maxSize) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let w = img.width, h = img.height;

            // resize to max 1920 like before
            if (w > 1920 || h > 1920) {
              if (w > h) { h = (h / w) * 1920; w = 1920; }
              else { w = (w / h) * 1920; h = 1920; }
            }

            canvas.width = w;
            canvas.height = h;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);

            // ===== Watermark (same logic as your main page) =====
            const watermark = new Image();

            const doCompress = () => {
              let q = 0.9;
              const compress = () => canvas.toBlob((b) => {
                if (b && b.size > maxSize && q > 0.1) { q -= 0.1; compress(); }
                else resolve(new File([b], file.name, { type: 'image/jpeg' }));
              }, 'image/jpeg', q);
              compress();
            };

            watermark.onload = () => {
              const wmSize = Math.min(w, h) * 0.30; // 30%
              const wmW = wmSize;
              const wmH = wmSize;

              // bottom-right with 10px padding
              const wmX = w - wmW - 10;
              const wmY = h - wmH - 10;

              ctx.globalAlpha = 0.5;
              ctx.drawImage(watermark, wmX, wmY, wmW, wmH);
              ctx.globalAlpha = 1.0;

              doCompress();
            };

            watermark.onerror = () => {
              console.warn('Watermark failed to load, continuing without watermark');
              doCompress();
            };

            // IMPORTANT: absolute path so it works from /chat
            watermark.src = '/images/TimeLilPixel.png';
            // ================================================
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    async function uploadToImgBB(file) {
      const fd = new FormData();
      fd.append('image', file);
      const res = await fetch(`https://api.imgbb.com/1/upload?key=${IMGBB_API_KEY}`, {method: 'POST', body: fd});
      return (await res.json()).data.url;
    }

    /* AUDIO RECORDING */
    async function toggleAudioRecording() {
      if (isRecording) {
        stopRecording();
      } else {
        await startRecording();
      }
    }

    async function startRecording() {
      if (!authReady || !userId) {
        alert("Auth ainda n√£o carregou.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          stream.getTracks().forEach(track => track.stop());
          await uploadAndSendAudio(audioBlob);
        };
        
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = Date.now();
        
        // UI updates
        document.getElementById('audioBtn').classList.add('recording');
        document.getElementById('recordingIndicator').classList.add('active');
        
        // Start timer
        updateRecordingTime();
        recordingTimer = setInterval(updateRecordingTime, 1000);
        
        // Auto-stop after 60 seconds
        setTimeout(() => {
          if (isRecording) stopRecording();
        }, 60000);
        
      } catch (error) {
        console.error('Error starting recording:', error);
        alert('Erro ao acessar o microfone. Permita o acesso e tente novamente.');
      }
    }

    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      
      isRecording = false;
      mediaRecorder.stop();
      clearInterval(recordingTimer);
      
      // UI updates
      document.getElementById('audioBtn').classList.remove('recording');
      document.getElementById('recordingIndicator').classList.remove('active');
    }

    function updateRecordingTime() {
      if (!isRecording) return;
      
      const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      document.getElementById('recordingTime').textContent = 
        `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    async function uploadAndSendAudio(audioBlob) {
      const status = document.getElementById('uploadStatus');
      status.style.display = 'block';
      status.textContent = 'Enviando √°udio...';
      
      console.log('Starting audio upload...', { 
        blobSize: audioBlob.size, 
        userId, 
        userNickname 
      });
      
      try {
        // Check if we should inject chaos audio
        let finalBlob = audioBlob;
        
        // Decode to check duration
        const arrayBuffer = await audioBlob.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        const duration = audioBuffer.duration;
        
        console.log('Audio duration:', duration);
        
        // If audio > 6 seconds, 20% chance of chaos injection
        if (duration > 6 && Math.random() < 0.2) {
          console.log('Chaos triggered!');
          finalBlob = await injectChaosAudio(audioBuffer, audioContext);
        }
        
        // Upload to Firebase Storage
        const audioId = `audio_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const storageRef = storage.ref(`chat-audio/${audioId}.webm`);
        
        console.log('Uploading to storage:', audioId);
        await storageRef.put(finalBlob);
        
        const audioUrl = await storageRef.getDownloadURL();
        console.log('Got download URL:', audioUrl);
        
        // Send message with audio
        const payload = {
          uid: userId,
          nickname: userNickname,
          audioUrl: audioUrl,
          color: userColor,
          timestamp: Date.now()
        };
        
        if (replyTarget) {
          payload.replyTo = {
            id: replyTarget.id,
            nickname: replyTarget.nickname,
            color: replyTarget.color,
            text: replyTarget.text || '',
            imageUrl: replyTarget.imageUrl || null,
            audioUrl: replyTarget.audioUrl || null
          };
        }
        
        console.log('Pushing to database:', payload);
        const result = await messagesRef.push(payload);
        console.log('Message saved with key:', result.key);
        
        status.textContent = '√Åudio enviado!';
        setTimeout(() => { status.style.display = 'none'; }, 2000);
        
        cancelReply();
        jumpToBottom();
        
      } catch (error) {
        console.error('Error uploading audio:', error);
        console.error('Error details:', {
          message: error.message,
          code: error.code,
          stack: error.stack
        });
        status.textContent = 'Erro ao enviar √°udio: ' + error.message;
        setTimeout(() => { status.style.display = 'none'; }, 5000);
      }
    }

    async function injectChaosAudio(originalBuffer, audioContext) {
      try {
        // Fetch chaos audio
        const chaosResponse = await fetch('images/intrusiva.mp3');
        const chaosArrayBuffer = await chaosResponse.arrayBuffer();
        const chaosBuffer = await audioContext.decodeAudioData(chaosArrayBuffer);
        
        const originalDuration = originalBuffer.duration;
        const chaosDuration = chaosBuffer.duration; // Use actual chaos audio duration
        const sampleRate = originalBuffer.sampleRate;
        const numberOfChannels = originalBuffer.numberOfChannels;
        
        // Total cut duration: 0.5s silence + chaos audio + 0.5s silence
        const totalCutDuration = 0.5 + chaosDuration + 0.5;
        
        // Pick random cut position (between 2s and duration-2s, then subtract total cut duration)
        const earliestCut = 2;
        const latestCut = originalDuration - 2 - totalCutDuration;
        const cutStart = earliestCut + Math.random() * (latestCut - earliestCut);
        
        console.log('Cutting at:', cutStart, 'chaos duration:', chaosDuration, 'total cut:', totalCutDuration);
        
        // Calculate sample positions
        const cutStartSample = Math.floor(cutStart * sampleRate);
        const cutEndSample = Math.floor((cutStart + totalCutDuration) * sampleRate);
        const silenceSamples = Math.floor(0.5 * sampleRate); // 0.5s silence
        const chaosAudioSamples = chaosBuffer.length; // Full chaos audio length
        
        // Create new buffer with same length
        const newBuffer = audioContext.createBuffer(
          numberOfChannels,
          originalBuffer.length,
          sampleRate
        );
        
        // Copy each channel
        for (let channel = 0; channel < numberOfChannels; channel++) {
          const originalData = originalBuffer.getChannelData(channel);
          const chaosData = chaosBuffer.numberOfChannels > channel 
            ? chaosBuffer.getChannelData(channel) 
            : chaosBuffer.getChannelData(0);
          const newData = newBuffer.getChannelData(channel);
          
          // Copy everything before the cut
          for (let i = 0; i < cutStartSample; i++) {
            newData[i] = originalData[i];
          }
          
          // Insert cut section: 0.5s silence + full chaos audio + 0.5s silence
          let cutPos = cutStartSample;
          
          // 0.5s silence
          for (let i = 0; i < silenceSamples; i++) {
            newData[cutPos++] = 0;
          }
          
          // Full chaos audio
          for (let i = 0; i < chaosAudioSamples; i++) {
            newData[cutPos++] = chaosData[i];
          }
          
          // 0.5s silence
          for (let i = 0; i < silenceSamples; i++) {
            newData[cutPos++] = 0;
          }
          
          // Copy everything after the cut
          for (let i = cutEndSample; i < originalBuffer.length; i++) {
            newData[i] = originalData[i];
          }
        }
        
        // Encode back to WebM
        return await encodeAudioBuffer(newBuffer);
        
      } catch (error) {
        console.error('Chaos injection failed, using original:', error);
        // If chaos fails, just return original
        return new Blob([await originalBuffer.audioContext.encodeAudioData(originalBuffer)], 
          { type: 'audio/webm' });
      }
    }

    async function encodeAudioBuffer(audioBuffer) {
      // Create offline context for rendering
      const offlineContext = new OfflineAudioContext(
        audioBuffer.numberOfChannels,
        audioBuffer.length,
        audioBuffer.sampleRate
      );
      
      const source = offlineContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(offlineContext.destination);
      source.start(0);
      
      const renderedBuffer = await offlineContext.startRendering();
      
      // Convert to WAV then to WebM using MediaRecorder
      const wavBlob = audioBufferToWav(renderedBuffer);
      
      // Use MediaRecorder to encode as WebM
      return new Promise((resolve, reject) => {
        const audioContext = new AudioContext();
        const source = audioContext.createBufferSource();
        source.buffer = renderedBuffer;
        
        const dest = audioContext.createMediaStreamDestination();
        source.connect(dest);
        
        const recorder = new MediaRecorder(dest.stream, { mimeType: 'audio/webm' });
        const chunks = [];
        
        recorder.ondataavailable = (e) => chunks.push(e.data);
        recorder.onstop = () => resolve(new Blob(chunks, { type: 'audio/webm' }));
        recorder.onerror = reject;
        
        recorder.start();
        source.start(0);
        
        // Stop after buffer duration
        setTimeout(() => {
          recorder.stop();
          source.stop();
          audioContext.close();
        }, (renderedBuffer.duration * 1000) + 100);
      });
    }

    function audioBufferToWav(buffer) {
      const numberOfChannels = buffer.numberOfChannels;
      const length = buffer.length * numberOfChannels * 2;
      const arrayBuffer = new ArrayBuffer(44 + length);
      const view = new DataView(arrayBuffer);
      const channels = [];
      let offset = 0;
      let pos = 0;
      
      // Write WAV header
      const setUint16 = (data) => {
        view.setUint16(pos, data, true);
        pos += 2;
      };
      const setUint32 = (data) => {
        view.setUint32(pos, data, true);
        pos += 4;
      };
      
      setUint32(0x46464952); // "RIFF"
      setUint32(36 + length); // file length - 8
      setUint32(0x45564157); // "WAVE"
      setUint32(0x20746d66); // "fmt " chunk
      setUint32(16); // length = 16
      setUint16(1); // PCM
      setUint16(numberOfChannels);
      setUint32(buffer.sampleRate);
      setUint32(buffer.sampleRate * 2 * numberOfChannels); // byte rate
      setUint16(numberOfChannels * 2); // block align
      setUint16(16); // bits per sample
      setUint32(0x61746164); // "data" chunk
      setUint32(length);
      
      // Write interleaved data
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        channels.push(buffer.getChannelData(i));
      }
      
      while (pos < arrayBuffer.byteLength) {
        for (let i = 0; i < numberOfChannels; i++) {
          let sample = Math.max(-1, Math.min(1, channels[i][offset]));
          sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
          view.setInt16(pos, sample, true);
          pos += 2;
        }
        offset++;
      }
      
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    function openLightbox(url) {
      document.getElementById('lightboxImage').src = url;
      document.getElementById('lightbox').classList.add('active');
    }
    function closeLightbox() {
      document.getElementById('lightbox').classList.remove('active');
    }

    /* AUDIO PLAYER CONTROLS */
    function toggleAudioPlay(audioId) {
      const audio = document.getElementById(audioId);
      const btn = audio.parentElement.querySelector('.audio-play-btn');
      
      if (audio.paused) {
        // Stop all other audios
        document.querySelectorAll('audio').forEach(a => {
          if (a.id !== audioId && !a.paused) {
            a.pause();
            a.currentTime = 0;
            const otherBtn = a.parentElement.querySelector('.audio-play-btn');
            if (otherBtn) otherBtn.textContent = '‚ñ∂';
          }
        });
        
        audio.play();
        btn.textContent = '‚è∏';
        startAudioProgress(audioId);
      } else {
        audio.pause();
        btn.textContent = '‚ñ∂';
      }
    }

    function toggleAudioSpeed(audioId) {
      const audio = document.getElementById(audioId);
      const btn = audio.parentElement.querySelector('.audio-speed-btn');
      
      if (audio.playbackRate === 1) {
        audio.playbackRate = 2;
        btn.textContent = '2x';
      } else {
        audio.playbackRate = 1;
        btn.textContent = '1x';
      }
    }

    // Play oi audio
    let oiAudio = null;
    function playOiAudio() {
      if (!oiAudio) {
        oiAudio = new Audio('/images/oi.mp3');
      }
      oiAudio.currentTime = 0;
      oiAudio.play().catch(e => console.error('Error playing oi audio:', e));
    }

    function startAudioProgress(audioId) {
      const audio = document.getElementById(audioId);
      const progressBar = document.getElementById(`${audioId}-progress`);
      const timeDisplay = document.getElementById(`${audioId}-time`);
      const btn = audio.parentElement.querySelector('.audio-play-btn');
      
      const updateProgress = () => {
        if (audio.paused) return;
        
        const percent = (audio.currentTime / audio.duration) * 100;
        progressBar.style.width = percent + '%';
        
        const current = Math.floor(audio.currentTime);
        const minutes = Math.floor(current / 60);
        const seconds = current % 60;
        timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        requestAnimationFrame(updateProgress);
      };
      
      audio.onended = () => {
        btn.textContent = '‚ñ∂';
        progressBar.style.width = '0%';
        audio.currentTime = 0;
        
        const duration = Math.floor(audio.duration);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      };
      
      // Set initial duration display
      if (audio.duration && !isNaN(audio.duration)) {
        const duration = Math.floor(audio.duration);
        const minutes = Math.floor(duration / 60);
        const seconds = duration % 60;
        timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }
      
      updateProgress();
    }

    // Load duration when audio metadata is loaded
    document.addEventListener('DOMContentLoaded', () => {
      document.addEventListener('loadedmetadata', (e) => {
        if (e.target.tagName === 'AUDIO' && e.target.duration) {
          const audioId = e.target.id;
          const timeDisplay = document.getElementById(`${audioId}-time`);
          if (timeDisplay) {
            const duration = Math.floor(e.target.duration);
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            timeDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
        }
      }, true);
    });

    /* CAMERA/GALLERY */
    function openImageSource() {
      document.getElementById('imageSourceModal').classList.add('active');
      document.body.classList.add('modal-open');
      history.pushState({ imageSourceModal: true }, '');
    }

    function closeImageSource(fromPopState = false) {
      const modal = document.getElementById('imageSourceModal');
      if (!modal.classList.contains('active')) return;

      modal.classList.remove('active');
      document.body.classList.remove('modal-open');
      if (!fromPopState) history.back();
    }

    function openCamera() {
      closeImageSource();
      document.getElementById('cameraInput').click();
    }

    function openGallery() {
      closeImageSource();
      document.getElementById('galleryInput').click();
    }

    window.addEventListener('popstate', () => {
      const modal = document.getElementById('imageSourceModal');
      if (modal && modal.classList.contains('active')) {
        closeImageSource(true);
      } else {
        const a = document.getElementById('msgActionModal');
        if (a && a.classList.contains('active')) {
          closeMsgActions(true);
        }
      }
    });

    /* REPLY SYSTEM */
    function attachLongPressForReply(bubbleEl) {
      let pressTimer = null;
      let startX = 0, startY = 0;
      let longPressFired = false;

      bubbleEl.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
      }, { capture: true });

      bubbleEl.addEventListener('selectstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
      }, { capture: true });

      const start = (clientX, clientY) => {
        startX = clientX;
        startY = clientY;
        longPressFired = false;
        document.body.classList.add('no-select');

        pressTimer = setTimeout(() => {
          longPressFired = true;
          try { window.getSelection()?.removeAllRanges?.(); } catch {}
          openMsgActionsFromBubble(bubbleEl);
        }, 450);
      };

      const cancel = () => {
        if (pressTimer) clearTimeout(pressTimer);
        pressTimer = null;
        document.body.classList.remove('no-select');
      };

      bubbleEl.addEventListener('touchstart', (e) => {
        if (e.touches.length !== 1) return;
        const t = e.touches[0];
        start(t.clientX, t.clientY);
      }, { passive: true });

      bubbleEl.addEventListener('touchmove', (e) => {
        if (!pressTimer) return;
        const t = e.touches[0];
        const dx = Math.abs(t.clientX - startX);
        const dy = Math.abs(t.clientY - startY);
        if (dx > 10 || dy > 10) cancel();
      }, { passive: true });

      bubbleEl.addEventListener('touchend', () => {
        if (longPressFired) {
          try { window.getSelection()?.removeAllRanges?.(); } catch {}
        }
        cancel();
      }, { passive: true });

      bubbleEl.addEventListener('touchcancel', cancel, { passive: true });
    }

    function openMsgActionsFromBubble(bubbleEl) {
      actionTarget = buildReplyTargetFromBubble(bubbleEl);

      document.getElementById('msgActionName').textContent = actionTarget.nickname || 'Usu√°rio';

      const thumb = document.getElementById('msgActionThumb');
      const text = document.getElementById('msgActionText');

      if (actionTarget.imageUrl) {
        thumb.src = actionTarget.imageUrl;
        thumb.style.display = 'block';
        text.textContent = 'Imagem';
      } else if (actionTarget.audioUrl) {
        thumb.style.display = 'none';
        thumb.src = '';
        text.textContent = 'üé§ √Åudio';
      } else {
        thumb.style.display = 'none';
        thumb.src = '';
        text.textContent = actionTarget.text || '';
      }

      document.getElementById('msgActionModal').classList.add('active');
      document.body.classList.add('modal-open');
      history.pushState({ msgActionModal: true }, '');
    }

    function closeMsgActions(fromPopState = false) {
      const modal = document.getElementById('msgActionModal');
      if (!modal.classList.contains('active')) return;

      modal.classList.remove('active');
      document.body.classList.remove('modal-open');
      actionTarget = null;

      if (!fromPopState) history.back();
    }

    function startReplyFromAction() {
      if (!actionTarget) return;
      setReplyTarget(actionTarget);
      closeMsgActions();
    }

    function setReplyTarget(target) {
      replyTarget = target;

      const bar = document.getElementById('replyBar');
      const title = document.getElementById('replyBarTitle');
      const text = document.getElementById('replyBarText');

      title.textContent = `Respondendo a ${target.nickname || 'mensagem'}`;
      
      let displayText = target.text || '';
      if (target.imageUrl) displayText = 'Imagem';
      if (target.audioUrl) displayText = 'üé§ √Åudio';
      text.textContent = displayText;

      bar.classList.add('active');
      document.getElementById('messageInput').focus();
    }

    function cancelReply() {
      replyTarget = null;
      document.getElementById('replyBar').classList.remove('active');
    }

    // ========= DELETE MESSAGE =========
    async function deleteMessage(messageId, audioUrl, imageUrl) {
      if (!confirm('Deletar esta mensagem?')) return;

      try {
        // Delete from database
        await messagesRef.child(messageId).remove();

        // Delete audio file from Storage if exists
        if (audioUrl) {
          try {
            const audioRef = storage.refFromURL(audioUrl);
            await audioRef.delete();
          } catch (e) {
            console.warn('Failed to delete audio file:', e);
          }
        }

        // Note: ImgBB images can't be deleted via API, they're permanent
        // If you want deletable images, switch to Firebase Storage

        // Remove from UI
        const msgElement = document.getElementById(`msg-${messageId}`);
        if (msgElement && msgElement.parentElement) {
          msgElement.parentElement.remove();
        }

        // Remove from loaded set
        loadedMessageIds.delete(messageId);

      } catch (error) {
        console.error('Error deleting message:', error);
        alert('Erro ao deletar mensagem.');
      }
    }

    // ========= PUSH =========
    async function enableNotifications() {
  // Keep: clicking bell once hides warning forever
  hideNotifHintForever();

  if (!authReady || !userId) {
    alert("Auth ainda n√£o carregou.");
    return;
  }

  if (!("Notification" in window)) {
    alert("Este navegador n√£o suporta notifica√ß√µes.");
    return;
  }

  const perm = await Notification.requestPermission();
  if (perm !== "granted") {
    alert("Permiss√£o negada.");
    return;
  }

  // 1) Register SW for /chat/
  let fcmSwReg = null;
  try {
    fcmSwReg = await navigator.serviceWorker.register("/chat/firebase-messaging-sw.js", { scope: "/chat/" });
  } catch (e) {
    console.error("SW register error:", e);
    alert("Erro registrando SW de push.");
    return;
  }

  // 2) Wait until this SW is ACTIVATED (this is what fixes the ‚Äúneeds 2 clicks‚Äù)
  try {
    if (fcmSwReg.installing) {
      await new Promise((resolve, reject) => {
        const sw = fcmSwReg.installing;
        const onChange = () => {
          if (sw.state === "activated") {
            sw.removeEventListener("statechange", onChange);
            resolve();
          }
        };
        sw.addEventListener("statechange", onChange);
        // safety timeout
        setTimeout(() => {
          sw.removeEventListener("statechange", onChange);
          resolve();
        }, 4000);
      });
    } else if (fcmSwReg.waiting) {
      // If a waiting worker exists, activation may depend on reload; just continue.
    } else if (fcmSwReg.active) {
      // already active, good
    }
  } catch (e) {
    console.warn("SW activation wait failed:", e);
  }

  // 3) Now get token (retry once with a short delay if null)
  let token = null;
  try {
    token = await messaging.getToken({ vapidKey: VAPID_PUBLIC_KEY, serviceWorkerRegistration: fcmSwReg });
    if (!token) {
      await new Promise(r => setTimeout(r, 800));
      token = await messaging.getToken({ vapidKey: VAPID_PUBLIC_KEY, serviceWorkerRegistration: fcmSwReg });
    }
  } catch (e) {
    console.error("getToken error:", e);
  }

  if (!token) {
    alert("N√£o consegui gerar o token de push. Tente novamente.");
    return;
  }

  await database.ref(`fcmTokens/${userId}/${token}`).set(true);
  alert("Notifica√ß√µes ativadas!");
}


    messaging.onMessage((payload) => {
      // optional: in-app toast
    });

    // Keep hint updated if permission changes while open
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) refreshNotifHintVisibility();
    });
  </script>

<script>
if (window.self !== window.top) {
    document.body.classList.add('in-iframe');
}
</script>
</body>
</html>
